// BlacklightController.cs
// Main controller for the blacklight puzzle. This script now acts as a central hub
// that clues can register themselves with.

using UnityEngine;
using System.Collections.Generic; // Using a List now instead of an array

public class BlacklightController : MonoBehaviour
{
    // --- Singleton Pattern ---
    // This makes the controller easily accessible from any other script without needing direct references.
    public static BlacklightController Instance { get; private set; }

    [Header("Effect Settings")]
    [Tooltip("The color the scene lights will change to during the blacklight effect.")]
    [SerializeField]
    private Color m_blacklightColor = new Color(0.6f, 0.4f, 1f);

    [Header("Component References")]
    [Tooltip("Optional: Assign the passthrough effect controller. If left null, it will be found automatically.")]
    [SerializeField]
    private PassthroughBlacklightEffect m_passthroughEffect;

    // --- Private State Storage ---
    private Light[] m_sceneLights;
    private Color[] m_originalLightColors;
    // UPDATED: Using a List so we can dynamically add/remove clues as they are created.
    private List<BlacklightClue> m_sceneClues = new List<BlacklightClue>();
    private bool m_isBlacklightActive = false;

    private void Awake()
    {
        // Set up the Singleton instance.
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
        }
        else
        {
            Instance = this;
        }
    }

    void Start()
    {
        // Find the Passthrough Effect Controller if it's not assigned
        if (m_passthroughEffect == null)
        {
            m_passthroughEffect = FindAnyObjectByType<PassthroughBlacklightEffect>();
        }
        if (m_passthroughEffect == null)
        {
            Debug.LogError("BlacklightController: Missing PassthroughBlacklightEffect in the scene!", this);
        }

        // Find all the lights generated by MRUK (or placed manually)
        m_sceneLights = FindObjectsByType<Light>(FindObjectsSortMode.None);
        m_originalLightColors = new Color[m_sceneLights.Length];
        for (int i = 0; i < m_sceneLights.Length; i++)
        {
            m_originalLightColors[i] = m_sceneLights[i].color;
        }

        // REMOVED: We no longer search for clues here. They will register themselves.
        
        // Ensure the effect is off at the start
        SetBlacklightState(false);
    }

    // --- NEW PUBLIC METHODS FOR CLUE REGISTRATION ---
    public void RegisterClue(BlacklightClue clue)
    {
        if (!m_sceneClues.Contains(clue))
        {
            m_sceneClues.Add(clue);
            Debug.Log($"BlacklightController: Clue '{clue.gameObject.name}' has registered. Total clues: {m_sceneClues.Count}");
        }
    }

    public void UnregisterClue(BlacklightClue clue)
    {
        if (m_sceneClues.Contains(clue))
        {
            m_sceneClues.Remove(clue);
            Debug.Log($"BlacklightController: Clue '{clue.gameObject.name}' has unregistered. Total clues: {m_sceneClues.Count}");
        }
    }
    
    /// <summary>
    /// Public method to easily toggle the blacklight effect on and off.
    /// This is called by your VoiceCommandController or any other trigger.
    /// </summary>
    public void ToggleBlacklight()
    {
        m_isBlacklightActive = !m_isBlacklightActive;
        Debug.Log("Toggling blacklight. New state is ON: " + m_isBlacklightActive);
        SetBlacklightState(m_isBlacklightActive);
    }

    /// <summary>
    /// The core function that changes the state of all related components.
    /// </summary>
    /// <param name="isOn">The desired state for the blacklight effect.</param>
    public void SetBlacklightState(bool isOn)
    {
        if (m_passthroughEffect != null)
        {
            m_passthroughEffect.SetEffect(isOn);
        }

        for (int i = 0; i < m_sceneLights.Length; i++)
        {
            if (m_sceneLights[i] != null)
            {
                m_sceneLights[i].color = isOn ? m_blacklightColor : m_originalLightColors[i];
            }
        }

        // The logic here remains the same, but it now uses the dynamically updated list.
        Debug.Log($"Attempting to set {m_sceneClues.Count} clues to state: {isOn}");
        foreach (var clue in m_sceneClues)
        {
            if (clue != null)
            {
                Debug.Log($"  -> Setting clue '{clue.gameObject.name}' to active state: {isOn}", clue.gameObject);
                //clue.SetRevealed(isOn);
            }
        }
    }
}
